"""
author: Oscar Namicano

import yt_dlp

# Função para baixar o vídeo
def download_video(url):
    # Configurações do yt-dlp
    ydl_opts = {
        'format': 'best',  # Baixa o melhor formato de vídeo e áudio
        'outtmpl': '%(title)s.%(ext)s',  # Nome do arquivo de saída será o título do vídeo
    }

    try:
        # Baixar o vídeo com as opções fornecidas
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            print(f"Iniciando o download do vídeo: {url}")
            ydl.download([url])  # Baixar o vídeo da URL
            print("Download concluído com sucesso!")
    except Exception as e:
        print(f"Erro ao baixar o vídeo: {e}")

# Pedir a URL do vídeo para o usuário
if __name__ == "__main__":
    video_url = input("Digite a URL do vídeo do YouTube: ")
    download_video(video_url)"""


from kivy.app import App
from kivy.config import Config
Config.set('input', 'mouse', 'mouse')
import os
from kivy import platform
import sys
import threading
import yt_dlp
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.textinput import TextInput
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.core.window import Window
from kivy.uix.progressbar import ProgressBar
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.filechooser import FileChooserListView
from kivy.uix.popup import Popup
from kivy.core.clipboard import Clipboard


# Verifique se estamos no Android antes de tentar usar android.permissions
if 'android' in sys.modules:
    from android.permissions import request_permissions, Permission, check_permission
    from android.storage import primary_external_storage_path

    def request_storage_permissions():
        request_permissions([Permission.WRITE_EXTERNAL_STORAGE, Permission.READ_EXTERNAL_STORAGE])
    import os

    def get_download_directory():
        download_dir = f'{str(primary_external_storage_path())}/VideoDown/'
        # Verifica se o diretório existe, caso contrário, cria
        if not os.path.exists(download_dir):
            request_storage_permissions()
            os.makedirs(download_dir)
        return download_dir

else:
    def request_storage_permissions():
        pass  # Não faz nada no desktop
    def get_download_directory():
        p = os.path.expanduser('~')+'\Downloads\VideoDown'
        if not os.path.exists(p):
            os.makedirs(p)
        return p  # Diretório padrão no desktop
    
def get_ffmpeg_path():
    '''
    Esta função define onde o programa vai encontrar o arquivo ffmpeg.exe.
    O ffmpeg é uma ferramenta poderosa para manipular arquivos de áudio e vídeo,
    neste aplicativo usamos ele para juntar/mesclar um video(sem som)
    com um audio baixados separadamente.

    RETORN:
        este funcao retorna ffmpeg_path indicando uma string correspondente ao caminho do ffmpeg.exe
    '''
    if getattr(sys, 'frozen', False):
        # When the script is run as a frozen executable (e.g., using PyInstaller),
        # the 'frozen' attribute of the 'sys' module is set to True.
        # 'sys._MEIPASS' is a special attribute created by PyInstaller that
        # points to the temporary directory where the bundled files are extracted.
        # This line constructs the full path to 'ffmpeg.exe' within that temporary directory.
        ffmpeg_path = os.path.join(sys._MEIPASS, 'ffmpeg.exe')
        return ffmpeg_path
    else:
        # When the script is run as a regular Python script, the 'frozen' attribute is False.
        # In this case, we assume that 'ffmpeg.exe' is located in the same directory
        # as the Python script. 'os.path.abspath('ffmpeg.exe')' gets the absolute path
        # to 'ffmpeg.exe' relative to the current working directory.
        ffmpeg_path = os.path.abspath('ffmpeg.exe')
        return ffmpeg_path
        

# Função para baixar o vídeo ou o áudio
def download_media(url, is_audio, progress_callback, completion_callback):
    ffmpeg_path = get_ffmpeg_path()
    ydl_opts = {
        'format': 'bestaudio/140' if is_audio else 'bestvideo+bestaudio/137', # Baixa o melhor formato de áudio ou vídeo
        'ffmpeg_location': ffmpeg_path,
        'merge_output_format': 'mp3' if is_audio else 'mp4',
        'outtmpl': os.path.join(get_download_directory(), '%(title)s.%(ext)s' if not is_audio else '%(title)s.mp3'),  # Define o diretório de download
        'progress_hooks': [progress_callback],  # Atualiza o progresso
        'noplaylist': True,
        'logger': MyLogger(),
    }
  
    """
    This block intends to covert a downloaded audio, but with .mp4
    extension. In alternative, '%(title)s.%(ext)s' if not is_audio else '%(title)s.mp3', do the same
    if is_audio:
        # Note: this if block was generated by chatgpt
        ydl_opts['postprocessors'] = [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }]
    """
        

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            print(f"Iniciando o download {'áudio' if is_audio else 'vídeo'}: {url}")
            request_storage_permissions()
            result = ydl.extract_info(url, download=True)
            print(result)
  # Baixar o conteúdo da URL
            filename = ydl.prepare_filename(result)
            #print(f"Download concluído com sucesso! Arquivo salvo como: {filename}")
            completion_callback(f"Download concluído com sucesso!\n{filename}")
                                
    except Exception as e:
        print(f"Erro ao baixar o conteúdo: {e}")
        completion_callback(f"Erro: {e}")

# Tela para inserir a URL e baixar o conteúdo (vídeo ou áudio)
from kivy.uix.widget import Widget

from kivy.uix.widget import Widget

class MyLogger:
    def debug(self, msg):
        pass
    def warning(self, msg):
        pass
    def error(self, msg):
        print(msg)


class CustomTextInput(TextInput):
    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos) and touch.button == 'right':
            self.show_context_menu(touch)
            return True
        return super().on_touch_down(touch)

    def show_context_menu(self, touch):
        layout = BoxLayout(orientation='vertical', size_hint=(None, None), size=(150, 200))

        btn_copy = Button(text="Copiar")
        btn_paste = Button(text="Colar")
        btn_cut = Button(text="Cortar")
        btn_select = Button(text="Selecionar Tudo")

        layout.add_widget(btn_copy)
        layout.add_widget(btn_paste)
        layout.add_widget(btn_cut)
        layout.add_widget(btn_select)

        popup = Popup(title='', content=layout, size_hint=(None, None), size=(150, 200), auto_dismiss=True)
        popup.open()

        btn_copy.bind(on_release=lambda x: (Clipboard.copy(self.selection_text), popup.dismiss()))
        btn_paste.bind(on_release=lambda x: (self.insert_text(Clipboard.paste()), popup.dismiss()))
        btn_cut.bind(on_release=lambda x: (Clipboard.copy(self.selection_text), self.delete_selection(), popup.dismiss()))
        btn_select.bind(on_release=lambda x: (self.select_all(), popup.dismiss()))

    def delete_selection(self):
        if self.selection_text:
            start, end = self.selection_from, self.selection_to
            self.text = self.text[:min(start, end)] + self.text[max(start, end):]


class DownloadScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.layout = BoxLayout(orientation='vertical', padding=20, spacing=20)  # Widget principal do aplicativo

        # Cabeçalho com título
        header_layout = BoxLayout(size_hint_y=None, height=40)
        header_label = Label(text='Download Center', font_size=25, bold=True, color=(1, 1, 1, 1), size_hint=(None, None), size=(200, 40))
        header_layout.add_widget(header_label)
        self.layout.add_widget(header_layout)

        url_layout = BoxLayout(orientation='horizontal', size_hint_y=None, height=40, spacing=5)

        # Campo para inserir a URL do conteúdo
        self.url_input = CustomTextInput(hint_text="Paste URL/cole o link do video", size_hint_y=None, height=40, background_normal='', background_active='', foreground_color=(0, 0, 0, 1), font_size=18)
        btn_paste = Button(text=' Colar ', size_hint=(None, None), width=60, height=40)
        btn_paste.bind(on_release=lambda x: (self.url_input.insert_text(Clipboard.paste())))

        url_layout.add_widget(self.url_input)
        url_layout.add_widget(btn_paste)
        self.layout.add_widget(url_layout)

        # Label para exibir mensagens
        self.message_label = Label(text="Waiting URL",
                                   color=(0.8, 0.8, 0.8, 1),
                                   size_hint=(1, None),
                                   height=40,
                                   text_size=(Window.width, 50),  # Ativa o alinhamento
                                   halign='center',
                                   valign='middle')
                                   
        self.layout.add_widget(self.message_label)

        # Barra de progresso
        self.progress_bar = ProgressBar(max=100, size_hint_y=None, height=20)
        self.layout.add_widget(self.progress_bar)

        # Botões "Baixar Vídeo" e "Baixar Áudio"
        buttons_layout = BoxLayout(size_hint_y=None, height=50, spacing=20)  # Layout horizontal para os botões
        self.download_video_button = Button(text="Download Vídeo", background_normal='', background_color=(0.3, 0.5, 0.8, 1), color=(1, 1, 1, 1), font_size=18)
        self.download_video_button.bind(on_press=self.start_video_download)
        buttons_layout.add_widget(self.download_video_button)

        self.download_audio_button = Button(text="Download Áudio", background_normal='', background_color=(0.3, 0.8, 0.3, 1), color=(1, 1, 1, 1), font_size=18)
        self.download_audio_button.bind(on_press=self.start_audio_download)
        buttons_layout.add_widget(self.download_audio_button)

        self.layout.add_widget(buttons_layout)

        # Botões "Sobre" e "Ver Downloads" na mesma linha
        info_buttons_layout = BoxLayout(size_hint_y=None, height=50, spacing=20)  # Layout horizontal para os botões
        self.view_downloads_button = Button(text="Files", background_normal='', background_color=(0.3, 0.5, 0.8, 1), color=(1, 1, 1, 1), font_size=18)
        self.view_downloads_button.bind(on_press=self.show_downloads)
        info_buttons_layout.add_widget(self.view_downloads_button)

        self.about_button = Button(text="About", background_normal='', background_color=(0.3, 0.5, 0.8, 1), color=(1, 1, 1, 1), font_size=18)
        self.about_button.bind(on_press=self.show_about_screen)
        info_buttons_layout.add_widget(self.about_button)

        self.layout.add_widget(info_buttons_layout)

        # Adicionando um Widget vazio que ocupará 50% ou 60% da altura
        # Ajustando o size_hint_y para 0.6 para ocupar 60% do espaço disponível
        self.layout.add_widget(Widget(size_hint_y=0.4))  # 40% para os widgets

        self.add_widget(self.layout)

    def start_video_download(self, instance):
        url = self.url_input.text
        if not url:
            self.message_label.text = "Invalid URL"
            return

        self.message_label.text = f"Starting download vídeo:\n{url}"

        # Iniciar o download em uma thread separada para vídeo
        download_thread = threading.Thread(target=download_media, args=(url, False, self.update_progress, self.on_download_complete))
        download_thread.start()

    def start_audio_download(self, instance):
        url = self.url_input.text
        if not url:
            self.message_label.text = "Invalid URL"
            return

        self.message_label.text = f"Starting download audio:\n{url}"

        # Iniciar o download em uma thread separada para áudio
        download_thread = threading.Thread(target=download_media, args=(url, True, self.update_progress, self.on_download_complete))
        download_thread.start()

######################## Functions to refactory ###########################
    def update_progress(self, progress_data):
        # Atualiza o progresso do download
        
        if progress_data['status'] == 'downloading':
            downloaded = progress_data.get('downloaded_bytes', 0)
            total = progress_data.get('total_bytes', 0)
            estimated_total = progress_data.get('total_bytes_estimate', 0)
            download_speed = progress_data.get('speed', 0) #returns bytes/s
            eta = progress_data.get('eta', 0)
            filename = progress_data.get('filename', 'Desconhecido').split('\\')[-1]
        
            if not total <= 0:
                # I was having alway 0 in total, so here i'm avoiding
                progress = (downloaded / total) * 100
                self.progress_bar.value = progress
                self.message_label.text = f"Baixando: {filename}\nVel: {self.format_speed(download_speed)}        |        Temp. Rest:{self.format_eta(eta)}"
            
            elif estimated_total > 0:
                progress = (downloaded / estimated_total) * 100
                self.progress_bar.value = progress
                self.message_label.text = f"Baixando: {filename}\nVel:  {self.format_speed(download_speed)}        |        Temp. Rest:  {self.format_eta(eta)}"

            else:
                self.message_label.text = "Preparing download..."

        elif progress_data['status'] == "error":
            self.message_label.text = "Erro no download"


    def on_download_complete(self, message):
        self.message_label.text = message

    def format_speed(self, speed):
        if speed is None:
            return "N/A"
        elif speed < 1024:
            return f"{speed:.2f} B/s"
        elif speed < 1024 * 1024:
            return f"{speed / 1024:.2f} KB/s"
        else:
            return f"{speed / (1024 * 1024):.2f} MB/s"
    def format_eta(self, eta):
        if eta is None:
            return "Tempo estimado: desconhecido"
        eta = int(eta)
        if eta < 60:
            return f"{eta}s"
        elif eta < 3600:
            return f"{eta // 60}m"
        elif eta < 86400:
            horas = eta // 3600
            minutos = (eta % 3600) // 60
            return f"{horas}h:{minutos}m"
        else:
            dias = eta // 86400
            horas = (eta % 86400) // 3600
            return f"{dias} dia(s) e {horas} hora(s)"


    def show_downloads(self, instance):
        # Troca para a tela de downloads
        self.manager.current = "downloads"

    def show_about_screen(self, instance):
        # Troca para a tela de informações sobre o app
        self.manager.current = "about"


# Tela para visualizar os downloads feitos (Agora um explorador de arquivos)
class DownloadsScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.layout = BoxLayout(orientation='vertical', padding=20, spacing=20)

        # Cabeçalho
        header_label = Label(text="Files Explorer", font_size=30, bold=True, color=(1, 1, 1, 1), size_hint=(None, None), size=(200, 100))
        self.layout.add_widget(header_label)

        # FileChooser para visualizar e navegar pelos arquivos
        request_storage_permissions()
        self.file_chooser = FileChooserListView(path=get_download_directory(),size_hint=(1, None), height=Window.height - 150)
        self.layout.add_widget(self.file_chooser)

        # Botão para voltar à tela de download
        self.back_button = Button(text="Back", size_hint_y=None, height=50, background_normal='', background_color=(0.3, 0.5, 0.8, 1), color=(1, 1, 1, 1), font_size=18)
        self.back_button.bind(on_press=self.go_back)
        self.layout.add_widget(self.back_button)

        self.add_widget(self.layout)

    def go_back(self, instance):
        # Volta para a tela de download
        self.manager.current = "download"

# Tela de "Sobre" - Informações sobre o app e a política de uso
class AboutScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.layout = BoxLayout(orientation='vertical', padding=20, spacing=20)

        # Cabeçalho
        header_label = Label(text="About the App", font_size=30, bold=True, color=(1, 1, 1, 1), size_hint=(None, None), size=(200, 100))
        self.layout.add_widget(header_label)

        # Informações sobre a versão e o programador
        version_label = Label(text="Version: 1.0.0", font_size=20, color=(1, 1, 1, 1))
        self.layout.add_widget(version_label)

        developer_label = Label(text="Programmer: Oscar Namicano", font_size=20, color=(1, 1, 1, 1))
        self.layout.add_widget(developer_label)

        # Adicionar política de uso e advertência sobre conteúdo protegido por direitos autorais
        legal_warning = Label(
            text=(
                "Política de Uso: O aplicativo permite o download de conteúdo de fontes públicas.\n"
                "No entanto, o usuário é responsável pelo uso legal do conteúdo baixado.\n"
                "Não é permitido baixar material protegido por direitos autorais sem a devida autorização."
            ),
            font_size=18,
            color=(1, 1, 1, 1)
        )
        self.layout.add_widget(legal_warning)

        # Botão para voltar à tela anterior
        back_button = Button(text="Back", size_hint_y=None, height=50, background_normal='', background_color=(0.3, 0.5, 0.8, 1), color=(1, 1, 1, 1), font_size=18)
        back_button.bind(on_press=self.go_back)
        self.layout.add_widget(back_button)

        self.add_widget(self.layout)

    def go_back(self, instance):
        self.manager.current = "download"

# Classe principal do app
class DownloadApp(App):
    def build(self):
        self.screen_manager = ScreenManager()

        if platform == 'android':
            from android.permissions import request_permissions, Permission

            request_permissions(
                [Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE]
            )

        

        # Adiciona as telas ao ScreenManager
        self.download_screen = DownloadScreen(name="download")
        self.downloads_screen = DownloadsScreen(name="downloads")
        self.about_screen = AboutScreen(name="about")

        self.screen_manager.add_widget(self.download_screen)
        self.screen_manager.add_widget(self.downloads_screen)
        self.screen_manager.add_widget(self.about_screen)

        return self.screen_manager
    def on_start(self):
        if platform == 'android':
            if not check_permission(Permission.WRITE_EXTERNAL_STORAGE):

                request_permissions([Permission.WRITE_EXTERNAL_STORAGE, Permission.READ_EXTERNAL_STORAGE])

if __name__ == '__main__':
    DownloadApp().run()